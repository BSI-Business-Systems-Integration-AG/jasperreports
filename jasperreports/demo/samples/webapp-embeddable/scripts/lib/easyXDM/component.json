{
  "name": "easyXDM",
  "version": "2.4.17",
  "description": "A javascript library providing cross-browser, cross-site messaging/method invocation.",
  "keywords": [
    "cross-domain",
    "rpc"
  ],
  "author": {
    "name": "oyvindkinsey",
    "email": "oyvind@kinsey.no"
  },
  "licenses": [
    {
      "type": "MIT"
    }
  ],
  "homepage": "http://easyxdm.net/",
  "main": "./easyXDM.js",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/hull/easyXDM.git"
  },
  "gitHead": "5980f27abbfb65a4c81713e29459ef9f3bae6cb4",
  "readme": "easyXDM - easy Cross-Domain Messaging\n=====================================\neasyXDM is a Javascript library that enables you as a developer to easily work around the limitation set in place by the Same Origin Policy, in turn making it easy to communicate and expose javascript API's across domain boundaries.\n\n**Some of the goals for the project are that it should**\n\n* be easy to use!!!\n* be self contained, <del>no dependencies</del> (Now requires Flash for the FlashTransport) (not counting JSON)\n* be light weight\n* be flexible\n* have good code quality (uses jslint etc)\n* have good documentation\n* be the best xdm-library in existence\n\nHow easyXDM works \n---------------\nAt the core easyXDM provides a transport stack capable of passing string based messages between two windows, a **consumer** (the main document) and a **provider** (a document included using an iframe).\nIt does this by using one of several available techniques, always selecting the most efficient one for the current browser.    \nFor all implementations the transport stack offers bi-directionality, reliability, queueing and sender-verification.\n\nUsing JavaScript only (no Flash, Silverlight, extra html files etc) easyXDM provides the following browsers with stacks with latency of less than 15ms:\n\n* IE8+ - using the PostMessageTransport\n* Opera 9+ - using the PostMessageTransport (support for both Operas old standard and the HTML5 standard)\n* Firefox 1-2 - using the FrameElementTransport\n* Firefox 3+ - using the PostMessageTransport\n* Safari 4+ - using the PostMessageTransport\n* Chrome 2+ - using the PostMessageTransport\n\nIn browsers not mentioned here, and not supporting the *postMessage* API, the following transports will be used, depending on support and configuation:\n\n* FlashTransport - Requires Flash 6+ and the swf property to be configured and will load a single swf into the document that functions as a factory. The swf has been audited by Google Security researchers. \n* NameTransport - Requires an html-file (name.html) to be hosted on each of the two domain. The cache-directives in the file allows the transport to pass messages with speeds similar to postMessage without incurring extra HTTP-requests.\n* HashTransport - If no other transport can be used, then the HashTransport will be used.\n\nHow to use easyXDM\n------------------\nWhen using easyXDM you first load the *consumer* document and then **let easyXDM load** the *provider*. This is by default done in a hidden iframe, but you can also configure easyXDM to display the iframe in a specific container, and with a specific style attached. \n\nThe library provides two main object types that utilize this transport stack:\n\nThe easyXDM.Socket\n-----------------\n.. is a thin wrapper around the transport stack and lets you send strings between the consumer and the provider.\n\nTo set up a simple Socket this is what you will need to add to the *consumer*\n\n```javascript\n\n    var socket = new easyXDM.Socket({\n        remote: \"http://path.to/provider/\", // the path to the provider\n        onMessage:function(message, origin) {\n            //do something with message\n        }\n    });\n```\n\nAnd this is what's needed for the *provider*\n\n```javascript\n    var socket = new easyXDM.Socket({\n        onMessage:function(message, origin) {\n            //do something with message\n        }\n    });\n```\n\nUse this for sending the strings to the other end:\n\n```javascript\n    socket.postMessage(\"hello world\");\n```\n\nIn addition the following config properties can be set for both consumer and provider\n\n* `onReady` - If you set this to a function, then this will be called once the communication has been established.\n* `local` {String} - To enable the NameTransport as a fallback, set this to point to the `name.html` file on the current domain.\n* `swf` {String} - To enable the FlashTransport for IE6/7 you need to point this towards your `easyxdm.swf` file. The swf must reside on one of the two domains (consumer and provider can use its own copy), or on a shared CDN used by both the consumer and provider.\n* `swfNoThrottle` {Boolean} - Set this to true if you want to have the swf/iframe placed visibly (20x20px top right corner) in order to avoid being throttled in newer versions of Flash\n* `swfContainer` {String || DOMElement) - Set this if you want to control where the swf is placed.\n\nThese properties can be set only on the consumer\n\n* `lazy` {Boolean} - If you set this to `true` then the iframe will not be created until the first use of the Socket\n* `container` {String || DOMElement} - Set this to an id or element if you want the iframe to be visible for interaction.\n* `props` {Object} - The key/value pairs of this object will be deep-copied onto the iframe. As an example, use `props: {style: {border: \"1px solid red\"} }` to set the border of the iframe to 1px solid red.\n* `remoteHelper` {String} - To enable the NameTransport as a fallback, set this to point to the `name.html` file on the provider.\n* `hash` {Boolean} - Whether to pass the setup data using the hash instead of using the query. This is mainly useful in scenarios where query arguments affects efficient caching or where the providers HTTP server does not support URL's with query parameters. Using the hash is not compatible with hash based history managers etc.\n\nThese properties can be set only on the provider\n\n* `acl` {String || String[]} Use this to only allow specific domains to consume this provider. The patterns can contain the wildcards ? and * as in the examples 'http://example.com', '*.foo.com' and '*dom?.com', or they can be regular expressions starting with ^ and ending with $. If none of the patterns match an Error will be thrown.\n\nA socket can be teared down (iframe removed etc) using \n\n```javascript\n    socket.destroy();\n```\n\nThe easyXDM.Rpc\n---------------\n... constructor lets you create a proxy object with method stubs and uses JSON-RPC to invoke these methods and return the responses.\n\nThe Rpc uses the same transport stack as the Socket, and so **uses the same config properties**.\n\nTo set up a simple Rpc this is what you will need to add to the *consumer*\n\n```javascript\n    var rpc = new easyXDM.Rpc({\n        remote: \"http://path.to/provider/\" // the path to the provider\n    }, \n    {\n        local: {\n            helloWorld: function(successFn, errorFn){\n                // here we expose a simple method with no arguments\n                // if we want to return a response, we can use `return ....`,\n                // or we can use the provided callbacks if the operation is async\n                // or an error occurred\n            }\n        },\n        remote: {\n            helloWorld:{\n                // here we tell the Rpc object to stub a method helloWorld for us\n            }\n        }\n    });\n```\n\nCall the methods like this \n\n```javascript\n    rpc.helloWorld(1,2,3, function(response){\n        // here we can do something with the return value from `helloWorld`\n    }, function(errorObj){\n        // here we can react to a possible error\n    };\n```\n\nAnd this is what's needed for the *provider*\n\n```javascript\n    var rpc = new easyXDM.Rpc({},\n    {\n        local: {\n            helloWorld: function(one, two, thre_args, successFn, errorFn){\n                // here we expose a simple method with three arguments\n                // that returns an object\n                return {\n                    this_is: \"an object\"\n                };\n            }\n        },\n        remote: {\n            helloWorld:{\n                // here we tell the Rpc object to stub a method helloWorld for us\n            }\n        }\n    });\n```\n\nCall the methods like this \n\n```javascript\n    rpc.helloWorld(); // easyXDM automatically changes it's behavior depending on the presence of callback methods for `success` and for `error`. \n```\n\nThe Rpc configurations `local` and `remote` properties can be left out if empty. Both properties can have multiple methods defined.\n\nWhen calling the stubs you can provide up to two callback functions after the expected arguments, the first one being the method that will receive the callback in case of a success, and the next the method that will receive the callback in case of an error.\n\nIf an error occurs in the execution of the stubbed method then this will be caught and passed back to the error handler. This means that you in the body of the exposed method can use ` throw \"custom error\";` to return a message, or you can pass a message, and an optional object containing error data to the error callback.\nIf the error handler is present, then this will be passed an object containing the properties\n\n* `message` {String} - The message returned from the invoked method\n* `data` {Object} - The optional error data passed back.\n\nIn addition to the `local` and `remote` properties, you can set the following\n\n* `serializer` {Object} - An object conforming with methods matching the standardized `window.JSON` object.\n\nIn order for easyXDM.Rpc to use JSON-RPC it needs access to functioning encode/decode methods for JSON, and this can be provided by setting the `serializer`. If not set easyXDM will try to use the native JSON object, and will even work with the faulty `toJSON ` and `evalJSON` provided by earlier Prototype Js.\n\nIf you want to conditionally include Douglas Crockfords JSON2 library (or any other that will provide window.JSON) then you can add this directly after the script that includes easyXDM\n\n```html\n    <script type=\"text/javascript\">\n        easyXDM.DomHelper.requiresJSON(\"http://path/to/json2.js\");\n    </script>\n```\n\nThis will only include it if not natively supported.\n\nAn rpc object can be teared down (iframe removed etc) using \n\n```javascript\n    rpc.destroy();\n```\n\nThe shipped /cors/ interface\n-----\nSince either end is free to use AJAX etc the Rpc object can be used to easily expose enable cross-domain AJAX. For this the library comes with a default `/cors/index.html` (`/cors/`) document that exposes a method `request(object config, function successFn, function errorFn)`, where config can have the following properties:\n\n* `url` {string} - The url to request\n* `method` {string} - GET or POST. Default POST\n* `headers` {object} - A map of headers to apply - the defaults are `\"Content-Type\": \"application/x-www-form-urlencoded\"` and `\"X-Requested-With\": \"XMLHttpRequest\"`. Set headers are added to the default, null values removed.\n* `timeout` {number} - the number of milliseconds before a timeout occurs. Default 10000 (10 seconds)\n* `data´ {object} - a map of the data to pass\n\nIf the request succeeds the success handler will be passed an object with the following properties\n\n* `data` {string} - the responseText\n* `status` {number} - The status of the request\n* `headers` {object} - a map of the returned headers\n\nIf the request fail the error handler will be passed an object with the following properties\n\n* `data` {string} - the responseText if available, or null\n* `status` {number} - The status of the request\n* `message` {string} - A friendly message explaining the error\n\nThis is how you can use it:\n\n```javascript\n    var rpc = new easyXDM.Rpc({\n    remote: \"http://foo.bar/cors/\"\n  },\n    {\n        remote: {\n      request: {}\n    }\n    });\n\n  rpc.request({\n    url: \"/resource/x/y/z/\",\n    method: \"POST\",\n    data: {foo: \"bar\", bar: \"foo\"}\n  }, function(response){\n    alert(response.data);\n  });\n```\n\neasyXDM.noConflict\n-----\n\nIf you want two or more instances of easyXDM to run on the same page, you can put your instance into a namespace using easyXDM.noConflict method. This method returns control of easyXDM global object to the other library and returns an instance of itself.\n\nThis is useful if you embed your code on the page and cannot guarantee that it does not already define window.easyXDM.\n\nIt also takes a single argument, a string representation of the namespace. We need it to get access to the instance in the parent window (when using SameOriginTransport).\n\nExample:\n\n```javascript\n  // Let's assume we already have an instance of easyXDM on the page, but\n  // we need to load another one and put it under PROJECT.easyXDM. Here is\n  // how you do it.\n  var PROJECT = { easyXDM: easyXDM.noConflict(\"PROJECT\") };\n```\n\nFor more information\n-----\n\nThere are several examples and demos available through the main [website](http://easyxdm.net/), and in the [documentation](http://easyxdm.net/docs/).\n\nTests\n-----\nFor development a test suit is used - you can run this here:\n\n* for the [current version ](http://easyxdm.net/current/tests/) \n* for the repository's [master#HEAD](http://easyxdm.net/dev/tests/)\n\n\nLicense\n=======\neasyXDM is distributed under the MIT license. Please keep the exisisting headers.\n\nAttribution\n======\nMain developer\nØyvind Sean Kinsey - <oyvind@kinsey.no>, @okinsey, http://kinsey.no\n\nThe following has contributed to the project\n\n* [Anton Kovalyov](http://self.kovalyov.net/) - Added the `noConflict` feature.\n* [Eli Grey](http://eligrey.com/) - The /cors/ interface is adapted from his project [pmxdr](http://github.com/eligrey/pmxdr/)\n* [Peter Michaux](http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting) - Feature detection is based on his article\n* [Juriy Zaytsev - kangax](http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/) - Implementation of isArray \n* ++ many people through feedback",
  "_id": "easyXDM@2.4.17"
}
